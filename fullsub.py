import os
import subprocess
import pysubs2
from moviepy.editor import VideoFileClip, vfx
from datetime import timedelta

import re
from dotenv import load_dotenv
import random
import whisper

# Carga las variables de entorno del archivo .env
load_dotenv()

# Inicializa el cliente de OpenAI con la clave de API del archivo .env



def time_str_to_timedelta(time_str):
    """Convierte una cadena de tiempo SRT a un objeto timedelta."""
    return timedelta(hours=int(time_str[0:2]), minutes=int(time_str[3:5]), 
                     seconds=int(time_str[6:8]), milliseconds=int(time_str[9:]))

def timedelta_to_time_str(td):
    """Convierte un objeto timedelta a una cadena de tiempo SRT con dos decimales en los milisegundos."""
    total_seconds = int(td.total_seconds())
    hours, remainder = divmod(total_seconds, 3600)
    minutes, seconds = divmod(remainder, 60)
    # Calcula los milisegundos con dos decimales
    milliseconds = int(td.microseconds / 10000)
    return f"{hours:02}:{minutes:02}:{seconds:02},{milliseconds:02}"

def split_text(transcript):
    # Initial split based on punctuation
    initial_sentences = re.split(r'(?<=[.!?¿¡,]) +', transcript)
    processed_sentences = []

    for sentence in initial_sentences:
        words = sentence.split()
        current_sentence = []

        for word in words:
            current_sentence.append(word)
            # When the current sentence has 7 or more words, join them and add to processed_sentences
            if len(current_sentence) >= 13:
                processed_sentences.append(' '.join(current_sentence))
                current_sentence = []  # Reset current_sentence to start a new one

        # Add the last sentence if there are any remaining words
        if current_sentence:
            processed_sentences.append(' '.join(current_sentence))

    return processed_sentences

def generate_subtitles(audio_file_path, subtitles_file_path):
    #Change the model of the audio
    model =whisper.load_model("small")
    result = model.transcribe(audio_file_path)
    transcript = result["text"]

    
    if not transcript:
        raise ValueError("La transcripción no se generó correctamente.")

    pattern = r'(\d+:\d+:\d+,\d+) --> (\d+:\d+:\d+,\d+)\n(.*?)\n\n'
    matches = re.findall(pattern, transcript, re.DOTALL)

    with open(subtitles_file_path, "w", encoding="utf-8") as srt_file:
        subtitle_index = 1
        start_time = timedelta(seconds=0)
        # Logic to split the transcript into sentences or phrases
        sentences = split_text(transcript)  # This is a naive approach; you might need a more sophisticated method.
        
        for sentence in sentences:
            # Logic to estimate the duration of the sentence
            duration = len(sentence.split()) / 2.7  # Example estimation
            end_time = start_time + timedelta(seconds=duration)
            
            # Write the subtitle entry to the SRT file
            srt_file.write(f"{subtitle_index}\n")
            srt_file.write(f"{timedelta_to_time_str(start_time)} --> {timedelta_to_time_str(end_time)}\n")
            srt_file.write(sentence.strip() + "\n\n")
            
            # Prepare for the next subtitle
            start_time = end_time
            subtitle_index += 1


    return subtitles_file_path

def convert_srt_to_ass(srt_file_path, ass_file_path):

    # Load the SRT file
    try:
        print(srt_file_path)
        subs = pysubs2.load(srt_file_path)
    except Exception as e:
        print(f"Se encontró un error: {e}")
    # ASS header (customized according to your needs)
    ass_header = """
[Script Info]
; Script generated by User
ScriptType: v4.00+
PlayResX: 1080
PlayResY: 1920
ScaledBorderAndShadow: yes

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default, Comic Sans MS, 130, &H00FFFF, &H00FFFFFF, &H00000000, &H00000000, 0, 0, 0, 0, 100, 100, 0, 0, 1, 3, 3, 2, 10, 10, 450, 1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
"""

    # Write the header to the ASS file
    with open(ass_file_path, "w", encoding="utf-8") as ass_file:
        ass_file.write(ass_header)

        # Convert each subtitle
        for sub in subs:
            # Convert start and end times to two decimal places
            start_time = "{:0>1}:{:0>2}:{:0>2}.{:0>2}".format(*pysubs2.time.ms_to_str(sub.start).split(':'), sub.start % 1000 // 10)
            end_time = "{:0>1}:{:0>2}:{:0>2}.{:0>2}".format(*pysubs2.time.ms_to_str(sub.end).split(':'), sub.end % 1000 // 10)
            #Cambiar a amarillo
            # Choose a random color from white, red, green, blue
            colors = ["&HFFFFFF", "&HFFCCCC", "&H8080FF", "&HC0FFC0"]

            random_color = random.choice(colors)

            # Convert subtitle text and add color transition effect
            text = sub.plaintext
            # ASS tag to gradually change color from yellow to a random color
            #Cambiar color 
            color_transition = f"\\1c&H00FFFF&\\t(0,500,\\1c{random_color}&)"

            line = f"Dialogue: 0,{start_time},{end_time},Default,,0,0,0,, {{{color_transition}}} {{\\fade(250,250)}} {text}\n"

            ass_file.write(line)

def add_subtitles(video_file, subtitles_file, output_file):
    """
    Agrega subtítulos a un video usando FFmpeg.

    :param video_file: Ruta completa al archivo de video.
    :param subtitles_file: Ruta completa al archivo de subtítulos ASS.
    :param output_file: Ruta completa al archivo de video de salida.
    """

   
    # Escapar los caracteres especiales en la ruta del archivo de subtítulos
    subtitles_file_escaped = subtitles_file.replace('\\', '\\\\').replace(':', '\\:')

    ffmpeg_cmd = [
        r'C:\\PATH_Programs\\ffmpeg.exe',
        '-i', video_file,
        '-vf', f"subtitles='{subtitles_file_escaped}'",
        '-c:v', 'libx264',
        '-crf', '28',
        '-preset', 'medium',
        '-c:a', 'copy',
        output_file
    ]

    subprocess.run(ffmpeg_cmd, check=True)




#video_file = r"outputvideos\None\None.mp4"

def fullsub(video_file):
    generate_subtitles(r"E:\\code\\Video 2\\audio_outputs\\output_final.wav", r"E:\\code\\Video 2\\sub\\subtitulos.srt")
    convert_srt_to_ass(r"E:\\code\\Video 2\\sub\\subtitulos.srt", r"E:\\code\\Video 2\\sub\\subtitulos.ass")
    output_file = video_file.replace(".mp4",",sub.mp4")
    subtitles_file = r"E:\\code\\Video 2\\sub\\subtitulos.ass"
    # Agrega los subtítulos al video
    add_subtitles(video_file, subtitles_file, output_file)
    print("termino")
    return output_file



#path = r"E:\\code\\Video 2\\videossalida\\Adaptaciones de Peces a Ecosistemas de Aguas Profundas vs. Arrecifes Coralinos\Adaptaciones de Peces a Ecosistemas de Aguas Profundas vs. Arrecifes Coralinos.mp4"
#res = fullsub(path)